#!/bin/sh
#
# A Git pre-receive hook to ensure all commits have valid Change-IDs.
# This hook is installed on the server side to validate incoming commits.
#
# To install this hook, copy it to the hooks directory of your Git repository:
# cp pre-receive /path/to/your/repo.git/hooks/
#
# Make sure it's executable:
# chmod +x /path/to/your/repo.git/hooks/pre-receive

# Function to check if a commit has a valid Change-Id
check_change_id() {
    commit_hash=$1

    # Get the commit message
    commit_msg=$(git log -1 --format=%B "$commit_hash")

    # Check if the commit message contains a valid Change-Id
    if ! echo "$commit_msg" | grep -q "^Change-Id: I[0-9a-f]\{40\}$"; then
        # Skip merge commits
        if echo "$commit_msg" | head -1 | grep -q "^Merge "; then
            return 0
        fi

        # Skip commits with special prefixes
        if echo "$commit_msg" | head -1 | grep -q "^Revert \|^Automated: \|^CI: "; then
            return 0
        fi

        echo "ERROR: Commit $commit_hash is missing a valid Change-Id"
        echo "Please install the commit-msg hook and amend your commit."
        echo "See hooks/README.md for instructions."
        return 1
    fi

    return 0
}

# Function to check if a ref update is to refs/for/
check_refs_for() {
    ref=$1

    # If this is a push to refs/for/, it's handled by the Gerrit workflow
    if echo "$ref" | grep -q "^refs/for/"; then
        return 0
    fi

    # If this is a push to refs/heads/, we need to check for Change-Ids
    if echo "$ref" | grep -q "^refs/heads/"; then
        return 2
    fi

    # Other refs (tags, notes, etc.) don't need Change-Ids
    return 0
}

# Process each ref update
while read old_rev new_rev ref; do
    # Skip if this is a branch deletion
    if [ "$new_rev" = "0000000000000000000000000000000000000000" ]; then
        continue
    fi

    # Check if this is a refs/for/ update
    check_refs_for "$ref"
    refs_for_status=$?

    # If this is not a refs/for/ or refs/heads/ update, skip
    if [ $refs_for_status -eq 0 ]; then
        continue
    fi

    # If this is a new branch, we need to check all commits
    if [ "$old_rev" = "0000000000000000000000000000000000000000" ]; then
        # Get all commits that are reachable from new_rev
        for commit in $(git rev-list "$new_rev"); do
            check_change_id "$commit" || exit 1
        done
    else
        # Get all new commits that are reachable from new_rev but not from old_rev
        for commit in $(git rev-list "$old_rev..$new_rev"); do
            check_change_id "$commit" || exit 1
        done
    fi
done

# All checks passed
exit 0
